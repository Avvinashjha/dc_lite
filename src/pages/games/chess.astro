---
import GameLayout from '../../layouts/GameLayout.astro';
---
<GameLayout gameName="Chess" description="Play chess against the computer with full rules — castling, en passant, promotion." instructions="Click a piece to select, click a highlighted square to move. You play <strong>White</strong>. Full rules: <strong>castling</strong>, <strong>en passant</strong>, <strong>pawn promotion</strong>. The AI plays Black." keywords="chess game, chess online, play chess, chess vs computer, free chess">
  <div id="chess-ui" style="display:flex;gap:1.5rem;justify-content:center;align-items:flex-start;width:100%;padding:1rem;">
    <div style="position:relative;">
      <canvas id="game" width="480" height="480"></canvas>
      <!-- Promotion dialog -->
      <div id="promo-dialog" style="display:none;position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);background:var(--color-surface);border:2px solid var(--color-border);border-radius:var(--radius-lg);padding:1rem;text-align:center;z-index:10;box-shadow:var(--shadow-lg);">
        <p style="font-size:0.85rem;font-weight:700;margin-bottom:0.75rem;">Promote pawn to:</p>
        <div id="promo-options" style="display:flex;gap:0.5rem;justify-content:center;"></div>
      </div>
    </div>
    <div id="chess-info" style="width:220px;flex-shrink:0;">
      <div id="turn-display" style="font-weight:700;font-size:0.85rem;margin-bottom:1rem;padding:0.5rem 0.75rem;border-radius:var(--radius-md);background:var(--color-surface);border:1px solid var(--color-border);text-align:center;min-height:40px;display:flex;align-items:center;justify-content:center;"></div>
      <div style="margin-bottom:1rem;">
        <div style="font-size:0.75rem;font-weight:600;text-transform:uppercase;color:var(--color-text-light);margin-bottom:0.4rem;">Captured by White</div>
        <div id="captured-white" style="font-size:1.25rem;min-height:1.5rem;line-height:1.8;"></div>
      </div>
      <div style="margin-bottom:1rem;">
        <div style="font-size:0.75rem;font-weight:600;text-transform:uppercase;color:var(--color-text-light);margin-bottom:0.4rem;">Captured by Black</div>
        <div id="captured-black" style="font-size:1.25rem;min-height:1.5rem;line-height:1.8;"></div>
      </div>
      <div style="font-size:0.75rem;font-weight:600;text-transform:uppercase;color:var(--color-text-light);margin-bottom:0.4rem;">Move History</div>
      <div id="move-history" style="font-family:var(--font-mono);font-size:0.75rem;max-height:200px;overflow-y:auto;background:var(--color-surface);border:1px solid var(--color-border);border-radius:var(--radius-md);padding:0.5rem;"></div>
    </div>
  </div>
</GameLayout>

<script is:inline>
(function(){
  var c = document.getElementById('game'), ctx = c.getContext('2d');
  // High-DPI canvas for sharp rendering
  var dpr = window.devicePixelRatio || 1;
  var SIZE = 480, SQ = SIZE / 8;
  c.width = SIZE * dpr; c.height = SIZE * dpr;
  c.style.width = SIZE + 'px'; c.style.height = SIZE + 'px';
  ctx.scale(dpr, dpr);
  // Use white-style glyphs for BOTH colors (♔♕♖♗♘♙) — fill color determines black vs white
  var PIECES = {K:'♔',Q:'♕',R:'♖',B:'♗',N:'♘',P:'♙',k:'♔',q:'♕',r:'♖',b:'♗',n:'♘',p:'♙'};
  var PIECE_NAMES = {K:'King',Q:'Queen',R:'Rook',B:'Bishop',N:'Knight',P:'Pawn',k:'King',q:'Queen',r:'Rook',b:'Bishop',n:'Knight',p:'Pawn'};
  var COORDS = 'abcdefgh';

  // Game state
  var board, turn, selected, validMoves, gameStatus, lastMove;
  var capturedWhite = [], capturedBlack = [];
  var moveHistory = [];
  var moveNum = 1;
  // Castling rights
  var canCastle = { wK: true, wQR: true, wKR: true, bK: true, bQR: true, bKR: true };
  // En passant target square
  var enPassantTarget = null;
  // Promotion pending
  var promoCallback = null;

  document.getElementById('score-display').style.display = 'none';
  document.getElementById('best-display').style.display = 'none';

  function isWhite(p) { return p && p === p.toUpperCase() && p !== '0'; }
  function isBlack(p) { return p && p === p.toLowerCase() && p !== '0'; }
  function isOwn(p, t) { return t === 'w' ? isWhite(p) : isBlack(p); }
  function isEnemy(p, t) { return t === 'w' ? isBlack(p) : isWhite(p); }
  function pieceColor(p) { return isWhite(p) ? 'w' : 'b'; }

  function initBoard() {
    board = [
      ['r','n','b','q','k','b','n','r'],
      ['p','p','p','p','p','p','p','p'],
      [0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0],
      ['P','P','P','P','P','P','P','P'],
      ['R','N','B','Q','K','B','N','R']
    ];
    turn = 'w'; selected = null; validMoves = []; gameStatus = ''; lastMove = null;
    capturedWhite = []; capturedBlack = [];
    moveHistory = []; moveNum = 1;
    canCastle = { wK: true, wQR: true, wKR: true, bK: true, bQR: true, bKR: true };
    enPassantTarget = null; promoCallback = null;
    document.getElementById('promo-dialog').style.display = 'none';
    updateInfo();
    draw();
  }

  function getMoves(r, c, b, castle, ep) {
    var p = b[r][c], moves = [], t = pieceColor(p), pl = p.toLowerCase();
    function add(nr, nc) {
      if (nr >= 0 && nr < 8 && nc >= 0 && nc < 8 && !isOwn(b[nr][nc], t)) {
        moves.push([nr, nc]); return !b[nr][nc];
      }
      return false;
    }
    function slide(dirs) { dirs.forEach(function(d) { for (var i = 1; i < 8; i++) { if (!add(r + d[0]*i, c + d[1]*i)) break; } }); }

    if (pl === 'p') {
      var dir = t === 'w' ? -1 : 1, start = t === 'w' ? 6 : 1;
      // Forward
      if (r + dir >= 0 && r + dir < 8 && !b[r + dir][c]) {
        moves.push([r + dir, c]);
        if (r === start && !b[r + dir * 2][c]) moves.push([r + dir * 2, c]);
      }
      // Captures
      if (c > 0 && r + dir >= 0 && r + dir < 8 && isEnemy(b[r + dir][c - 1], t)) moves.push([r + dir, c - 1]);
      if (c < 7 && r + dir >= 0 && r + dir < 8 && isEnemy(b[r + dir][c + 1], t)) moves.push([r + dir, c + 1]);
      // En passant
      if (ep && r + dir === ep[0]) {
        if (c - 1 === ep[1]) moves.push([ep[0], ep[1]]);
        if (c + 1 === ep[1]) moves.push([ep[0], ep[1]]);
      }
    }
    if (pl === 'r') slide([[0,1],[0,-1],[1,0],[-1,0]]);
    if (pl === 'b') slide([[1,1],[1,-1],[-1,1],[-1,-1]]);
    if (pl === 'q') slide([[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]]);
    if (pl === 'n') [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]].forEach(function(d) { add(r+d[0], c+d[1]); });
    if (pl === 'k') {
      [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]].forEach(function(d) { add(r+d[0], c+d[1]); });
      // Castling
      if (castle) {
        var row = t === 'w' ? 7 : 0;
        if (r === row && c === 4) {
          // King-side
          var canKS = t === 'w' ? (castle.wK && castle.wKR) : (castle.bK && castle.bKR);
          if (canKS && !b[row][5] && !b[row][6] && b[row][7] && b[row][7].toLowerCase() === 'r') {
            if (!inCheck(b, t) && !isSquareAttacked(b, row, 5, t) && !isSquareAttacked(b, row, 6, t)) {
              moves.push([row, 6]);
            }
          }
          // Queen-side
          var canQS = t === 'w' ? (castle.wK && castle.wQR) : (castle.bK && castle.bQR);
          if (canQS && !b[row][3] && !b[row][2] && !b[row][1] && b[row][0] && b[row][0].toLowerCase() === 'r') {
            if (!inCheck(b, t) && !isSquareAttacked(b, row, 3, t) && !isSquareAttacked(b, row, 2, t)) {
              moves.push([row, 2]);
            }
          }
        }
      }
    }
    return moves;
  }

  function isSquareAttacked(b, r, c, byColor) {
    var enemy = byColor === 'w' ? 'b' : 'w';
    for (var rr = 0; rr < 8; rr++) for (var cc = 0; cc < 8; cc++) {
      if (isOwn(b[rr][cc], enemy)) {
        var m = getMoves(rr, cc, b, null, null);
        for (var i = 0; i < m.length; i++) if (m[i][0] === r && m[i][1] === c) return true;
      }
    }
    return false;
  }

  function makeMove(b, fr, fc, tr, tc, ep) {
    var nb = b.map(function(r) { return r.slice(); });
    var piece = nb[fr][fc];
    var captured = nb[tr][tc];
    nb[tr][tc] = piece; nb[fr][fc] = 0;

    // En passant capture
    if (piece.toLowerCase() === 'p' && ep && tr === ep[0] && tc === ep[1] && !captured) {
      captured = nb[fr][tc]; nb[fr][tc] = 0;
    }
    // Castling rook move
    if (piece.toLowerCase() === 'k' && Math.abs(tc - fc) === 2) {
      if (tc === 6) { nb[tr][5] = nb[tr][7]; nb[tr][7] = 0; } // King-side
      if (tc === 2) { nb[tr][3] = nb[tr][0]; nb[tr][0] = 0; } // Queen-side
    }
    // Pawn promotion (default to queen, caller handles choice)
    if (piece === 'P' && tr === 0) nb[tr][tc] = 'Q';
    if (piece === 'p' && tr === 7) nb[tr][tc] = 'q';

    return { board: nb, captured: captured };
  }

  function inCheck(b, t) {
    var kr = -1, kc = -1, king = t === 'w' ? 'K' : 'k';
    for (var r = 0; r < 8; r++) for (var cc = 0; cc < 8; cc++) if (b[r][cc] === king) { kr = r; kc = cc; }
    if (kr < 0) return true;
    return isSquareAttacked(b, kr, kc, t);
  }

  function legalMoves(r, c, b) {
    var t = pieceColor(b[r][c]);
    var raw = getMoves(r, c, b, canCastle, enPassantTarget);
    return raw.filter(function(m) {
      var result = makeMove(b, r, c, m[0], m[1], enPassantTarget);
      return !inCheck(result.board, t);
    });
  }

  function hasLegalMoves(t, b) {
    for (var r = 0; r < 8; r++) for (var cc = 0; cc < 8; cc++) {
      if (isOwn(b[r][cc], t) && legalMoves(r, cc, b).length > 0) return true;
    }
    return false;
  }

  function doMove(fr, fc, tr, tc, promoChoice) {
    var piece = board[fr][fc];
    var result = makeMove(board, fr, fc, tr, tc, enPassantTarget);

    // Handle promotion choice
    if (promoChoice && piece === 'P' && tr === 0) result.board[tr][tc] = promoChoice;
    if (promoChoice && piece === 'p' && tr === 7) result.board[tr][tc] = promoChoice;

    // Record captured piece
    if (result.captured) {
      if (isWhite(result.captured)) capturedBlack.push(result.captured);
      else capturedWhite.push(result.captured);
    }

    // Update castling rights
    if (piece === 'K') { canCastle.wK = false; canCastle.wKR = false; canCastle.wQR = false; }
    if (piece === 'k') { canCastle.bK = false; canCastle.bKR = false; canCastle.bQR = false; }
    if (piece === 'R' && fr === 7 && fc === 0) canCastle.wQR = false;
    if (piece === 'R' && fr === 7 && fc === 7) canCastle.wKR = false;
    if (piece === 'r' && fr === 0 && fc === 0) canCastle.bQR = false;
    if (piece === 'r' && fr === 0 && fc === 7) canCastle.bKR = false;

    // Update en passant target
    enPassantTarget = null;
    if (piece.toLowerCase() === 'p' && Math.abs(tr - fr) === 2) {
      enPassantTarget = [(fr + tr) / 2, fc];
    }

    // Move notation
    var notation = '';
    var isCastle = piece.toLowerCase() === 'k' && Math.abs(tc - fc) === 2;
    if (isCastle) { notation = tc === 6 ? 'O-O' : 'O-O-O'; }
    else {
      if (piece.toLowerCase() !== 'p') notation += piece.toUpperCase();
      if (result.captured) notation += (piece.toLowerCase() === 'p' ? COORDS[fc] : '') + 'x';
      notation += COORDS[tc] + (8 - tr);
    }

    board = result.board;
    lastMove = [fr, fc, tr, tc];
    turn = turn === 'w' ? 'b' : 'w';

    // Check status
    if (!hasLegalMoves(turn, board)) {
      if (inCheck(board, turn)) {
        gameStatus = turn === 'w' ? 'Checkmate! Black wins.' : 'Checkmate! White wins.';
        notation += '#';
      } else {
        gameStatus = 'Stalemate — Draw!';
      }
    } else if (inCheck(board, turn)) {
      gameStatus = 'Check!';
      notation += '+';
    } else {
      gameStatus = '';
    }

    // Record move
    if (turn === 'b') { moveHistory.push(moveNum + '. ' + notation); }
    else { moveHistory[moveHistory.length - 1] += ' ' + notation; moveNum++; }

    selected = null; validMoves = [];
    updateInfo(); draw();
  }

  // --- AI: Minimax with Alpha-Beta Pruning (depth 3) ---
  var pieceVal = {p:100, n:320, b:330, r:500, q:900, k:20000};
  var PST = {
    p:[[0,0,0,0,0,0,0,0],[50,50,50,50,50,50,50,50],[10,10,20,30,30,20,10,10],[5,5,10,27,27,10,5,5],[0,0,0,25,25,0,0,0],[5,-5,-10,0,0,-10,-5,5],[5,10,10,-25,-25,10,10,5],[0,0,0,0,0,0,0,0]],
    n:[[-50,-40,-30,-30,-30,-30,-40,-50],[-40,-20,0,0,0,0,-20,-40],[-30,0,10,15,15,10,0,-30],[-30,5,15,20,20,15,5,-30],[-30,0,15,20,20,15,0,-30],[-30,5,10,15,15,10,5,-30],[-40,-20,0,5,5,0,-20,-40],[-50,-40,-30,-30,-30,-30,-40,-50]],
    b:[[-20,-10,-10,-10,-10,-10,-10,-20],[-10,0,0,0,0,0,0,-10],[-10,0,10,10,10,10,0,-10],[-10,5,5,10,10,5,5,-10],[-10,0,10,10,10,10,0,-10],[-10,10,10,10,10,10,10,-10],[-10,5,0,0,0,0,5,-10],[-20,-10,-10,-10,-10,-10,-10,-20]],
    r:[[0,0,0,0,0,0,0,0],[5,10,10,10,10,10,10,5],[-5,0,0,0,0,0,0,-5],[-5,0,0,0,0,0,0,-5],[-5,0,0,0,0,0,0,-5],[-5,0,0,0,0,0,0,-5],[-5,0,0,0,0,0,0,-5],[0,0,0,5,5,0,0,0]],
    q:[[-20,-10,-10,-5,-5,-10,-10,-20],[-10,0,0,0,0,0,0,-10],[-10,0,5,5,5,5,0,-10],[-5,0,5,5,5,5,0,-5],[0,0,5,5,5,5,0,-5],[-10,5,5,5,5,5,0,-10],[-10,0,5,0,0,0,0,-10],[-20,-10,-10,-5,-5,-10,-10,-20]],
    k:[[20,30,10,0,0,10,30,20],[20,20,0,0,0,0,20,20],[-10,-20,-20,-20,-20,-20,-20,-10],[-20,-30,-30,-40,-40,-30,-30,-20],[-30,-40,-40,-50,-50,-40,-40,-30],[-30,-40,-40,-50,-50,-40,-40,-30],[-30,-40,-40,-50,-50,-40,-40,-30],[-30,-40,-40,-50,-50,-40,-40,-30]]
  };

  function evaluate(b) {
    var s = 0, wMobility = 0, bMobility = 0;
    for (var r = 0; r < 8; r++) for (var cc = 0; cc < 8; cc++) {
      var p = b[r][cc]; if (!p) continue;
      var v = pieceVal[p.toLowerCase()] || 0;
      var t = PST[p.toLowerCase()];
      if (t) v += isWhite(p) ? t[r][cc] : t[7-r][cc];
      // Mobility bonus
      var moves = getMoves(r, cc, b, null, null);
      if (isWhite(p)) { wMobility += moves.length; s += v; }
      else { bMobility += moves.length; s -= v; }
    }
    // Mobility matters (approx 3 centipawns per move)
    s += (wMobility - bMobility) * 3;
    return s;
  }

  // Get all legal moves for a side
  function allLegalMoves(b, t, ep) {
    var moves = [];
    for (var r = 0; r < 8; r++) for (var cc = 0; cc < 8; cc++) {
      if (!isOwn(b[r][cc], t)) continue;
      var raw = getMoves(r, cc, b, canCastle, ep);
      raw.forEach(function(m) {
        var result = makeMove(b, r, cc, m[0], m[1], ep);
        if (!inCheck(result.board, t)) moves.push([r, cc, m[0], m[1]]);
      });
    }
    return moves;
  }

  // Move ordering: captures and checks first for better pruning
  function orderMoves(moves, b) {
    return moves.sort(function(a, c) {
      var scoreA = 0, scoreC = 0;
      // Captures are valuable
      if (b[a[2]][a[3]]) scoreA += pieceVal[b[a[2]][a[3]].toLowerCase()] || 0;
      if (b[c[2]][c[3]]) scoreC += pieceVal[b[c[2]][c[3]].toLowerCase()] || 0;
      // Moving to center is good
      var centerDist = function(r, c) { return Math.abs(r - 3.5) + Math.abs(c - 3.5); };
      scoreA -= centerDist(a[2], a[3]) * 5;
      scoreC -= centerDist(c[2], c[3]) * 5;
      return scoreC - scoreA;
    });
  }

  // Minimax with alpha-beta pruning
  function minimax(b, depth, alpha, beta, maximizing, ep) {
    if (depth === 0) return evaluate(b);

    var t = maximizing ? 'w' : 'b';
    var moves = allLegalMoves(b, t, ep);

    if (moves.length === 0) {
      if (inCheck(b, t)) return maximizing ? -99999 + (3 - depth) : 99999 - (3 - depth);
      return 0; // Stalemate
    }

    moves = orderMoves(moves, b);

    if (maximizing) {
      var maxEval = -Infinity;
      for (var i = 0; i < moves.length; i++) {
        var m = moves[i];
        var result = makeMove(b, m[0], m[1], m[2], m[3], ep);
        var newEp = null;
        if (b[m[0]][m[1]] && b[m[0]][m[1]].toLowerCase() === 'p' && Math.abs(m[2] - m[0]) === 2)
          newEp = [(m[0] + m[2]) / 2, m[1]];
        var ev = minimax(result.board, depth - 1, alpha, beta, false, newEp);
        maxEval = Math.max(maxEval, ev);
        alpha = Math.max(alpha, ev);
        if (beta <= alpha) break;
      }
      return maxEval;
    } else {
      var minEval = Infinity;
      for (var i = 0; i < moves.length; i++) {
        var m = moves[i];
        var result = makeMove(b, m[0], m[1], m[2], m[3], ep);
        var newEp = null;
        if (b[m[0]][m[1]] && b[m[0]][m[1]].toLowerCase() === 'p' && Math.abs(m[2] - m[0]) === 2)
          newEp = [(m[0] + m[2]) / 2, m[1]];
        var ev = minimax(result.board, depth - 1, alpha, beta, true, newEp);
        minEval = Math.min(minEval, ev);
        beta = Math.min(beta, ev);
        if (beta <= alpha) break;
      }
      return minEval;
    }
  }

  function aiMove() {
    var moves = allLegalMoves(board, 'b', enPassantTarget);
    if (moves.length === 0) return;

    moves = orderMoves(moves, board);
    var bestScore = Infinity, bestMove = moves[0];

    for (var i = 0; i < moves.length; i++) {
      var m = moves[i];
      var result = makeMove(board, m[0], m[1], m[2], m[3], enPassantTarget);
      var newEp = null;
      if (board[m[0]][m[1]] && board[m[0]][m[1]].toLowerCase() === 'p' && Math.abs(m[2] - m[0]) === 2)
        newEp = [(m[0] + m[2]) / 2, m[1]];
      var sc = minimax(result.board, 2, -Infinity, Infinity, true, newEp);
      if (sc < bestScore) { bestScore = sc; bestMove = m; }
    }
    doMove(bestMove[0], bestMove[1], bestMove[2], bestMove[3]);
  }

  // --- Drawing ---
  function draw() {
    var colors = { light: '#f0d9b5', dark: '#b58863', selLight: '#f6f668', selDark: '#baca2b', moveLight: '#cdd26a', moveDark: '#aaa23a', lastLight: '#cdd16a55', lastDark: '#aaa13955', checkBg: '#ff000044' };

    for (var r = 0; r < 8; r++) for (var cc = 0; cc < 8; cc++) {
      var light = (r + cc) % 2 === 0;
      var bg = light ? colors.light : colors.dark;

      // Last move highlight
      if (lastMove && ((r === lastMove[0] && cc === lastMove[1]) || (r === lastMove[2] && cc === lastMove[3]))) {
        bg = light ? '#f7f77a' : '#c8c828';
      }
      // Selected piece
      if (selected && selected[0] === r && selected[1] === cc) {
        bg = light ? colors.selLight : colors.selDark;
      }

      ctx.fillStyle = bg;
      ctx.fillRect(cc * SQ, r * SQ, SQ, SQ);

      // Check highlight on king
      if (board[r][cc] && board[r][cc].toLowerCase() === 'k') {
        var kt = pieceColor(board[r][cc]);
        if (inCheck(board, kt) && kt === turn) {
          ctx.fillStyle = colors.checkBg;
          ctx.fillRect(cc * SQ, r * SQ, SQ, SQ);
        }
      }

      // Valid move indicators
      if (validMoves.some(function(m) { return m[0] === r && m[1] === cc; })) {
        if (board[r][cc]) {
          // Capture: corner triangles
          ctx.fillStyle = 'rgba(0,0,0,0.15)';
          ctx.beginPath(); ctx.moveTo(cc*SQ, r*SQ); ctx.lineTo(cc*SQ+12, r*SQ); ctx.lineTo(cc*SQ, r*SQ+12); ctx.fill();
          ctx.beginPath(); ctx.moveTo((cc+1)*SQ, r*SQ); ctx.lineTo((cc+1)*SQ-12, r*SQ); ctx.lineTo((cc+1)*SQ, r*SQ+12); ctx.fill();
          ctx.beginPath(); ctx.moveTo(cc*SQ, (r+1)*SQ); ctx.lineTo(cc*SQ+12, (r+1)*SQ); ctx.lineTo(cc*SQ, (r+1)*SQ-12); ctx.fill();
          ctx.beginPath(); ctx.moveTo((cc+1)*SQ, (r+1)*SQ); ctx.lineTo((cc+1)*SQ-12, (r+1)*SQ); ctx.lineTo((cc+1)*SQ, (r+1)*SQ-12); ctx.fill();
        } else {
          // Empty: dot
          ctx.fillStyle = 'rgba(0,0,0,0.15)';
          ctx.beginPath(); ctx.arc(cc*SQ+SQ/2, r*SQ+SQ/2, 8, 0, Math.PI*2); ctx.fill();
        }
      }

      // Pieces
      if (board[r][cc]) {
        var px = cc * SQ + SQ / 2, py = r * SQ + SQ / 2 + 1;
        var isW = isWhite(board[r][cc]);
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';

        // Draw with shadow for depth
        ctx.save();
        ctx.shadowColor = 'rgba(0,0,0,0.35)';
        ctx.shadowBlur = 3;
        ctx.shadowOffsetX = 1;
        ctx.shadowOffsetY = 2;

        ctx.font = 'bold 44px "Segoe UI Symbol", "Apple Color Emoji", "Noto Color Emoji", serif';

        // Outline stroke (dark border for both)
        ctx.lineWidth = 2.5;
        ctx.strokeStyle = isW ? '#2c2c2c' : '#2c2c2c';
        ctx.strokeText(PIECES[board[r][cc]], px, py);

        // Fill — white or dark
        ctx.fillStyle = isW ? '#ffffff' : '#3a3a3a';
        ctx.fillText(PIECES[board[r][cc]], px, py);

        ctx.restore();

        // Inner definition line
        ctx.font = 'bold 44px "Segoe UI Symbol", "Apple Color Emoji", "Noto Color Emoji", serif';
        ctx.strokeStyle = isW ? 'rgba(0,0,0,0.12)' : 'rgba(255,255,255,0.15)';
        ctx.lineWidth = 0.5;
        ctx.strokeText(PIECES[board[r][cc]], px, py);
      }
    }

    // Coordinates
    ctx.font = 'bold 9px sans-serif';
    for (var i = 0; i < 8; i++) {
      ctx.fillStyle = i % 2 === 0 ? colors.dark : colors.light;
      ctx.textAlign = 'left'; ctx.textBaseline = 'bottom';
      ctx.fillText(8 - i, 2, i * SQ + 12);
      ctx.textAlign = 'right'; ctx.textBaseline = 'bottom';
      ctx.fillStyle = (7 + i) % 2 === 0 ? colors.dark : colors.light;
      ctx.fillText(COORDS[i], i * SQ + SQ - 2, SIZE - 2);
    }

    // Game status overlay
    if (gameStatus && gameStatus !== 'Check!') {
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      ctx.fillRect(0, SIZE/2 - 35, SIZE, 70);
      ctx.fillStyle = '#fff'; ctx.font = 'bold 24px sans-serif';
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.fillText(gameStatus, SIZE/2, SIZE/2);
    }
  }

  function updateInfo() {
    var td = document.getElementById('turn-display');
    if (gameStatus && gameStatus !== 'Check!') {
      td.textContent = gameStatus;
      td.style.background = 'var(--color-primary)'; td.style.color = '#fff';
    } else {
      td.textContent = (turn === 'w' ? '⬜ White' : '⬛ Black') + "'s turn" + (gameStatus === 'Check!' ? ' — Check!' : '');
      td.style.background = ''; td.style.color = '';
      if (gameStatus === 'Check!') { td.style.background = '#fecaca'; td.style.color = '#dc2626'; }
    }
    document.getElementById('captured-white').textContent = capturedWhite.map(function(p) { return PIECES[p]; }).join(' ');
    document.getElementById('captured-black').textContent = capturedBlack.map(function(p) { return PIECES[p]; }).join(' ');
    document.getElementById('move-history').innerHTML = moveHistory.map(function(m) { return '<div>' + m + '</div>'; }).join('');
    var mh = document.getElementById('move-history');
    mh.scrollTop = mh.scrollHeight;
  }

  // --- Promotion UI ---
  function showPromotion(t, callback) {
    var opts = t === 'w' ? ['Q','R','B','N'] : ['q','r','b','n'];
    var el = document.getElementById('promo-options');
    el.innerHTML = '';
    opts.forEach(function(p) {
      var btn = document.createElement('button');
      btn.textContent = PIECES[p];
      btn.style.cssText = 'font-size:2.5rem;width:56px;height:56px;border:2px solid var(--color-border);border-radius:var(--radius-md);background:var(--color-background);cursor:pointer;transition:all 150ms;line-height:1;';
      btn.addEventListener('mouseenter', function() { this.style.borderColor = 'var(--color-primary)'; this.style.transform = 'scale(1.1)'; });
      btn.addEventListener('mouseleave', function() { this.style.borderColor = 'var(--color-border)'; this.style.transform = 'scale(1)'; });
      btn.addEventListener('click', function() {
        document.getElementById('promo-dialog').style.display = 'none';
        callback(p);
      });
      el.appendChild(btn);
    });
    document.getElementById('promo-dialog').style.display = '';
  }

  // --- Click handler ---
  c.addEventListener('click', function(e) {
    if (turn !== 'w' || promoCallback) return;
    if (gameStatus && gameStatus !== 'Check!') return;
    var rect = c.getBoundingClientRect();
    var cc = Math.floor((e.clientX - rect.left) * (8 / rect.width));
    var r = Math.floor((e.clientY - rect.top) * (8 / rect.height));
    if (r < 0 || r > 7 || cc < 0 || cc > 7) return;

    if (selected) {
      if (validMoves.some(function(m) { return m[0] === r && m[1] === cc; })) {
        var piece = board[selected[0]][selected[1]];
        // Check if pawn promotion
        if (piece === 'P' && r === 0) {
          var sr = selected[0], sc = selected[1];
          showPromotion('w', function(choice) {
            doMove(sr, sc, r, cc, choice);
            if (turn === 'b' && !gameStatus.match(/Checkmate|Stalemate|Draw/)) setTimeout(aiMove, 400);
          });
          return;
        }
        doMove(selected[0], selected[1], r, cc);
        if (turn === 'b' && !gameStatus.match(/Checkmate|Stalemate|Draw/)) setTimeout(aiMove, 400);
      } else {
        selected = null; validMoves = [];
        if (isWhite(board[r][cc])) { selected = [r, cc]; validMoves = legalMoves(r, cc, board); }
        draw();
      }
    } else {
      if (isWhite(board[r][cc])) { selected = [r, cc]; validMoves = legalMoves(r, cc, board); }
      draw();
    }
  });

  document.getElementById('btn-start').style.display = 'none';
  document.getElementById('btn-restart').style.display = '';
  document.getElementById('btn-restart').onclick = initBoard;
  document.getElementById('btn-pause').style.display = 'none';
  initBoard();
})();
</script>

<style>
  #chess-ui { max-width: 100%; overflow: hidden; }
  #chess-ui > div:first-child { max-width: 100%; }
  #chess-ui canvas { max-width: 100%; height: auto !important; }
  @media (max-width: 768px) {
    #chess-ui { flex-direction: column !important; align-items: center !important; flex-wrap: wrap !important; padding: 0.5rem !important; gap: 1rem !important; }
    #chess-info { width: 100% !important; }
  }
</style>
