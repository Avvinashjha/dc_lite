---
import ToolLayout from "../../layouts/ToolLayout.astro";
import CodeEditor from "../../components/CodeEditor.astro";
---

<ToolLayout
  title="Code Formatter & Preview"
  description="Format and minify code in your browser with side-by-side CodeMirror preview and syntax highlighting."
  toolName="Code Formatter & Preview"
  keywords="code formatter, javascript formatter, json formatter, code beautifier, code preview, codemirror"
>
  <div class="tool-row">
    <div class="tool-row__field">
      <label class="tool-panel__label" for="language">Language</label>
      <select id="language" class="tool-input">
        <option value="javascript">JavaScript</option>
        <option value="json">JSON</option>
        <option value="text">Plain Text</option>
      </select>
    </div>
    <div class="tool-row__field">
      <label class="tool-panel__label" for="indent-size">Indent</label>
      <select id="indent-size" class="tool-input">
        <option value="2">2 spaces</option>
        <option value="4">4 spaces</option>
      </select>
    </div>
  </div>

  <div class="tool-actions">
    <button id="btn-format" class="tool-btn tool-btn--primary">Format</button>
    <button id="btn-minify" class="tool-btn">Minify</button>
    <button id="btn-copy" class="tool-btn">Copy Output</button>
    <button id="btn-sample" class="tool-btn">Load Sample</button>
    <button id="btn-clear" class="tool-btn">Clear</button>
  </div>

  <div class="tool-panels">
    <div class="tool-panel">
      <span class="tool-panel__label">Input</span>
      <CodeEditor id="code-formatter-input" minHeight={320} />
    </div>
    <div class="tool-panel">
      <span class="tool-panel__label">Preview</span>
      <CodeEditor id="code-formatter-output" minHeight={320} />
    </div>
  </div>

  <div id="status"></div>
</ToolLayout>

<script>
  import { createCodeEditor } from "../../utils/codeEditor";

  const sampleByLanguage = {
    javascript: [
      "const users=[{name:'Ada',score:90},{name:'Linus',score:84}];",
      "function topScorer(items){return items.sort((a,b)=>b.score-a.score)[0]}",
      "console.log(topScorer(users));",
    ].join("\n"),
    json: '{"name":"DailyCoder","features":["tools","courses","blog"],"active":true,"meta":{"users":1240,"rating":4.9}}',
    text: "Paste any text and format/minify for supported languages.",
  };

  const statusEl = document.getElementById("status");
  const languageEl = document.getElementById("language");
  const indentEl = document.getElementById("indent-size");
  const formatBtn = document.getElementById("btn-format");
  const minifyBtn = document.getElementById("btn-minify");
  const copyBtn = document.getElementById("btn-copy");
  const sampleBtn = document.getElementById("btn-sample");
  const clearBtn = document.getElementById("btn-clear");

  const inputEditor = createCodeEditor({
    rootId: "code-formatter-input",
    doc: sampleByLanguage.javascript,
    language: "javascript",
    lineWrapping: true,
  });

  const outputEditor = createCodeEditor({
    rootId: "code-formatter-output",
    doc: "",
    language: "javascript",
    readOnly: true,
    lineWrapping: true,
  });

  function setStatus(message, type) {
    statusEl.className = type === "error" ? "tool-error" : "tool-success";
    statusEl.textContent = message;
  }

  function formatJson(value, indent) {
    return JSON.stringify(JSON.parse(value), null, indent);
  }

  function minifyJson(value) {
    return JSON.stringify(JSON.parse(value));
  }

  function formatJavaScript(code, indentSize) {
    const indentUnit = " ".repeat(indentSize);
    let out = "";
    let indentLevel = 0;
    let inSingle = false;
    let inDouble = false;
    let inTemplate = false;
    let inLineComment = false;
    let inBlockComment = false;
    let escape = false;

    function appendIndent() {
      out += indentUnit.repeat(Math.max(indentLevel, 0));
    }

    function ensureNewLine() {
      if (!out.endsWith("\n")) out += "\n";
    }

    function trimLineEnd() {
      out = out.replace(/[ \t]+$/g, "");
    }

    for (let i = 0; i < code.length; i += 1) {
      const ch = code[i];
      const next = code[i + 1] || "";

      if (inLineComment) {
        out += ch;
        if (ch === "\n") {
          inLineComment = false;
          appendIndent();
        }
        continue;
      }

      if (inBlockComment) {
        out += ch;
        if (ch === "*" && next === "/") {
          out += "/";
          i += 1;
          inBlockComment = false;
        }
        continue;
      }

      if (inSingle || inDouble || inTemplate) {
        out += ch;
        if (escape) {
          escape = false;
        } else if (ch === "\\") {
          escape = true;
        } else if (inSingle && ch === "'") {
          inSingle = false;
        } else if (inDouble && ch === '"') {
          inDouble = false;
        } else if (inTemplate && ch === "`") {
          inTemplate = false;
        }
        continue;
      }

      if (ch === "/" && next === "/") {
        out += "//";
        i += 1;
        inLineComment = true;
        continue;
      }

      if (ch === "/" && next === "*") {
        out += "/*";
        i += 1;
        inBlockComment = true;
        continue;
      }

      if (ch === "'") {
        inSingle = true;
        out += ch;
        continue;
      }

      if (ch === '"') {
        inDouble = true;
        out += ch;
        continue;
      }

      if (ch === "`") {
        inTemplate = true;
        out += ch;
        continue;
      }

      if (/\s/.test(ch)) {
        if (!out.endsWith(" ") && !out.endsWith("\n")) {
          out += " ";
        }
        continue;
      }

      if (ch === "{") {
        trimLineEnd();
        if (!out.endsWith(" ") && !out.endsWith("\n")) out += " ";
        out += "{";
        ensureNewLine();
        indentLevel += 1;
        appendIndent();
        continue;
      }

      if (ch === "}") {
        indentLevel -= 1;
        trimLineEnd();
        ensureNewLine();
        appendIndent();
        out += "}";
        if (next && next !== ";" && next !== "," && next !== ")" && next !== "]") {
          ensureNewLine();
          appendIndent();
        }
        continue;
      }

      if (ch === ";") {
        out += ";";
        ensureNewLine();
        appendIndent();
        continue;
      }

      if (ch === ",") {
        out += ", ";
        continue;
      }

      out += ch;
    }

    return out
      .split("\n")
      .map((line) => line.replace(/[ \t]+$/g, ""))
      .join("\n")
      .replace(/\n{3,}/g, "\n\n")
      .trim();
  }

  function minifyJavaScript(code) {
    return code
      .replace(/\/\*[\s\S]*?\*\//g, "")
      .replace(/\/\/[^\n\r]*/g, "")
      .replace(/\s+/g, " ")
      .replace(/\s*([{}()[\];,:=+\-*/<>!?&|])\s*/g, "$1")
      .trim();
  }

  function getLanguage() {
    return languageEl.value;
  }

  function updateLanguage() {
    const language = getLanguage();
    inputEditor.setLanguage(language);
    outputEditor.setLanguage(language);
    setStatus("Language changed to " + language + ".", "success");
  }

  function runFormatter(mode) {
    const language = getLanguage();
    const indentSize = Number(indentEl.value);
    const source = inputEditor.getValue().trim();

    if (!source) {
      outputEditor.setValue("");
      setStatus("Input is empty.", "error");
      return;
    }

    try {
      let result = source;

      if (language === "json") {
        result = mode === "minify" ? minifyJson(source) : formatJson(source, indentSize);
      } else if (language === "javascript") {
        result = mode === "minify" ? minifyJavaScript(source) : formatJavaScript(source, indentSize);
      } else if (language === "text") {
        result = mode === "minify" ? source.replace(/\s+/g, " ").trim() : source;
      }

      outputEditor.setValue(result);
      setStatus((mode === "minify" ? "Minified" : "Formatted") + " successfully.", "success");
    } catch (error) {
      outputEditor.setValue("");
      setStatus("Unable to process input: " + (error && error.message ? error.message : String(error)), "error");
    }
  }

  languageEl.addEventListener("change", function () {
    updateLanguage();
  });

  formatBtn.addEventListener("click", function () {
    runFormatter("format");
  });

  minifyBtn.addEventListener("click", function () {
    runFormatter("minify");
  });

  copyBtn.addEventListener("click", function () {
    const value = outputEditor.getValue();
    if (!value) {
      setStatus("No output to copy.", "error");
      return;
    }
    navigator.clipboard.writeText(value);
    setStatus("Output copied.", "success");
  });

  sampleBtn.addEventListener("click", function () {
    const language = getLanguage();
    inputEditor.setValue(sampleByLanguage[language] || "");
    outputEditor.setValue("");
    setStatus("Sample loaded.", "success");
  });

  clearBtn.addEventListener("click", function () {
    inputEditor.setValue("");
    outputEditor.setValue("");
    setStatus("Cleared.", "success");
  });
</script>

<style>
  .tool-row {
    display: flex;
    flex-wrap: wrap;
    gap: 0.75rem;
    margin-bottom: 0.75rem;
  }

  .tool-row__field {
    flex: 1;
    min-width: 220px;
  }
</style>
